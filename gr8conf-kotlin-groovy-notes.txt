Why Kotlin

* Have fun
* less code, more productivity
* write once, deploy across JVM, JS, native, IOS, android, etc.
* similar to scala, but less complicated, compiles faster, and supports fewer advanced features
* simple like groovy, but more powerful static typing than @CompileStatic - example?
* first class functions
* extension functions like c# extension functions
* properties compile to fields and getter/setter
* singletons/objects
* null pointers create compile errors, use ? like groovy for nullable values, nullable annotations are pain
* explicit mutable/immutable
* when is more flexible than java switch, less than pattern matching scala
* no checked exceptions to simplify how developers handle them
* spread operator
* data classes like @Canonical
* sealed classes allow compile to deduce full set of allowable implementation types
* delegation allows composition to be used instead of inheritance, and allows for creation of dsl languages (along with extension functions)
- minimize syntactic overhead, maximize structure, remove boilerplate
* covariance/contravariance - in/out
* higher order functions as parameters, return values, properties
* coroutines allow lightweight concurrency
- async/await similar to c# and others
* excellent java/groovy interop

Comparisons to Groovy:

1) Extension functions vs. extension modules
2) Nullability checks / no NPEs in Kotlin / var vs. val
3) data classes vs POGOs
4) constructors
5) String templates and quotes
6) functions
7) Control
8) Type inference
9) collection operators comparison and mutability

TODO
* Testing - Spock vs. Kotlintest/Spek/Junit5 with mockito-kotlin
* Kotlin provides delegation, lazy, lateinit keywords, Groovy has AST transformations (Delegate, Lazy, etc) via annotations
* Kotlin has singleton object, groovy uses Java static methods

Other Topics
* Kotlin has no checked exceptions - same as Groovy
* higher-order functions
* sealed classes
* Concurrency - Groovy has CompletableFuture, GPars, and other libraries, Kotlin has coroutines/actors/channels/async-await and CompletableFuture and other libraries tools
* Interoperability with Java examples for Kotlin and Groovy
* Groovy runtime metaprogramming - closest in kotlin would be kotlin reflection
* Simple DSL example in each
* Dependency injection - @Inject constructor notation
* method interceptors/aop requires classes/functions to be open. default is closed (final)
